\documentclass[a4paper]{article}
\usepackage[a4paper,left=3cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{{./images/}}
\usepackage{hyperref}

\usepackage{algorithm}
\floatname{algorithm}{Algorisme} % Cambia "Algorithm" por "Algorisme"

\usepackage{algpseudocode}
\usepackage{titling}
\usepackage{lipsum}
\usepackage{color}

\title{\textbf{\huge Algorismia}\\[0.5cm]
	\textbf{\Large Estudi Experimental de Connectivitat i Percolació de Grafs}}
\author{\emph{Pau Belda, Guillem Cabré, Marc Peñalver, Prisca Oleart}}
\date{\textbf{Curs 2024-25, Quatrimestre de tardor}}

\renewcommand*\contentsname{Continguts}
\renewcommand{\figurename}{Figura}

\begin{document}
	
	\begin{titlepage}
		\clearpage\maketitle
		\thispagestyle{empty}
	\end{titlepage}
	
	\tableofcontents
	\clearpage
	
	\section{Definicions}
	
	\subsection{Graf}
	
	\subsection{Percolació}
	
	\subsection{Transició de Fase}
	
	\subsection{Objectius de la Experimentació}
	
	\newpage
	\section{Grafs Seleccionats}
	
	\subsection{Erdős-Rényi}
	
	\begin{algorithm}
		\caption{Generació de graf Erdős-Rényi $G(n, p)$}
		\begin{algorithmic} [1]
			\State Inicialitzar el graf $g$ amb $n$ nodes
			\For{$i = 0$ fins a $n-1$}
			\For{$j = i + 1$ fins a $n-1$}
			\If{rand01() \textless\, $p$}
			\State Afegir una aresta entre $i$ i $j$ al graf $g$
			\EndIf
			\EndFor
			\EndFor
			\State Retornar el graf $g$
		\end{algorithmic}
	\end{algorithm}
	
	El generador de grafos Erdős-Rényi crea un graf aleatoriitzant la connexió entre nodes. Sigui $p$ la probabilitat d'establir una aresta entre qualsevol parell de nodes del graf. Per a cada parell de nodes $(i, j)$, es genera un nombre aleatori mitjançant la funció $rand01()$, que retorna un valor entre 0 i 1. Si aquest valor és menor que $p$, s'estableix una aresta entre $i$ i $j$. Aquest procés es repeteix per a tots els parells possibles de nodes. \\
	
	La instrucció $j = i + 1$ en el bucle interior assegura que només es considerin les arestes entre nodes diferents i evita la duplicació d'arestes. Això és important perquè en un graf no dirigit, l'aresta entre $i$ i $j$ és la mateixa que l'aresta entre $j$ i $i$. D'aquesta manera, es redueix el nombre de connexions a calcular i s'assegura que cada aresta es consideri només una vegada. \\
	
	\subsection{Square-Grid}
	
	\subsection{Triangular-Grid}
	
	\subsection{Random-Geometric}
	
	\subsection{Barábasi-Albert}
	
	\newpage
	\section{Algoritmes}
	
	\subsection{Percolació per Nodes}
	
	\subsection{Percolació per Arestes}
	
	\subsection{Càlcul de Components Connexes}
	
	\newpage
	\section{Experimentació}
	
	Per dur a terme l'experimentació del projecte, hem utilitzat diferents eines. Hem programat dos programes en \texttt{C++}, un llenguatge que ens ofereix molta eficàcia temporal i espacial. Aquests programes són el \texttt{main} i el \texttt{runner}. També hem dissenyat un fitxer de classe \texttt{graph} amb tots els atributs i funcions necessàries per operar amb els grafs. Aquesta classe representa els grafs com a llistes d'adjacència. \\
	
	Per compilar aquests programes, hem fet ús del programari lliure \texttt{make}, que automatitza i paral·litza el compilatge i l'enllaç. \\
	
	A més, hem dissenyat scripts per a l'interpret \texttt{R}, que és un programari de tractament de dades que ens analitzarà i generarà gràfics dels resultats dels estudis, que estaran en format \texttt{.csv}. \\
	
	Més informació del procés d'experimentació es pot trobar en el GitHub del projecte, premeu \href{https://github.com/Willyllem88/PercolationConnectivity}{\texttt{aquí}} per accedir-hi. Allà, a part del codi, també podreu consultar més informació sobre la generació de grafs, les dependències del programa per compilar-lo i executar-lo, com inserir els paràmetres pels programes i més. \\
	
	\subsection{Metodologia}
	
	El programa \texttt{main}, mitjançant la classe \texttt{graph}, ens ha permès analitzar les propietats del canvi de fase a partir dels paràmetres inicials. Aquests paràmetres són els següents:
	
	\begin{itemize}
		\item \textbf{RandomSeed}: La llavor per al generador aleatori.
		\item \textbf{NúmeroMínimNodes}: El nombre mínim de nodes del graf.
		\item \textbf{NúmeroMàximNodes}: El nombre màxim de nodes del graf.
		\item \textbf{NúmeroNodesStep}: Increment dels nodes en cada iteració.
		\item \textbf{IteracionsPerObtenirResultat}: El nombre de vegades que es provarà la configuració per probabilitat $p$ de percolació i per nombre de vèrtex $n$.
		\item \textbf{ModePercolació}: Tipus de percolació per nodes o per arestes.
		\item \textbf{PathResultat}: Fitxer on es guardaran els resultats.
		\item \textbf{AlgorismeGeneradorGraf}: Algoritme utilitzat per generar el graf (per exemple, Erdős-Rényi, Square-Grid, etc.).
		\item \textbf{ParàmetresAlgorisme}: Paràmetres addicionals per al generador de graf (opcional segons l'algorisme).
	\end{itemize}
	
	A partir d'aquests paràmetres, el programa \texttt{main} escriurà un fitxer \texttt{PATH.csv} que posteriorment serà analitzat mitjançant el software de tractament de dades \texttt{R}. \\
	
	Per altra banda, tenim el programa \texttt{runner}, que rebrà com a input un fitxer de text. Aquest fitxer tindrà un llistat de paràmetres per diferents experiments del programa \texttt{main}. Un exemple d'això seria:
	
	\begin{verbatim}
		RGN   MIN MAX  STEP ITs   PERC-MODE  RESULT-PATH      GEN-ALGORITM    PARAMETERS-GEN
		------------------------------------------------------------------------------------
		21312 10  100   10  1000  NODE_PERC  ./data/test1.csv Erdos-Renyi        0.1
		35353 50  500   50  1000  EDGE_PERC  ./data/test2.csv Random-Geometric   0.3
		72479 100 1000  100 100   EDGE_PERC  ./data/test3.csv Square-Grid
	\end{verbatim}
	
	El programa \texttt{runner}, per cada fila del fitxer que rep, inicialitzarà una instància del programa \texttt{main}, aconseguint d'aquesta manera automatitzar molt més els tests, podent córrer diferents programes \texttt{main} simultàniament. \\
	
	\subsection{Programa Main}
	
	Per entendre els resultats també s'ha d'entendre les decisions que s'han pres per la recollida de dades. Analitzarem el programa `main` mitjançant un pseudocodi per no entrar en conceptes avançats de `C++`. A continuació vegeu una mostra del pseudocodi: \\
	
	\begin{algorithm}
		\caption{Descripció de l'experiment}
		\begin{algorithmic}[1]
			\State Seleccionar opcions de configuració
			\State Inicialitzar el generador de nombres aleatoris
			\State Obrir l'arxiu CSV i escriure la capçalera
			\For{$n$ in range(MIN\_NB\_NODES, MAX\_NB\_NODES + 1, NB\_NODES\_STEP)}
			\For{$p$ des de 0 fins a 1 amb pas 0.01}
			\State Inicialitzar el comptador de grafos connectats
			\For{$i = 0$ fins a TRIES\_PER\_P}
			\Repeat
			\State Generar el graf seleccionat($p$, $n$, $params$)
			\Until{el graf és connex}
			\State Aplicar percolació (per nodes o arestes) al graf
			\If{el graf percolat és connex}
			\State Incrementar el comptador de grafos connectats
			\EndIf
			\EndFor
			\State Escriure entrada resultant al CSV
			\EndFor
			\EndFor
		\end{algorithmic}
	\end{algorithm}
	
	Ara, analitzarem el codi. Per començar, el programa preguntarà per totes les opcions necessàries. D'aquesta manera, ens podem permetre tenir un sol programa que pugui fer tot el que necessitem i que sigui altament modular. S'utilitzarà la llavor per generar nombres aleatoris, i així l'experiment podrà ser repetit amb els mateixos resultats. Després, crearà el fitxer \texttt{PATH.csv}, al qual s'hi inseriran entrades que posteriorment s'analitzaran. \\
	
	Ara analitzarem l'algorisme encarregat de generar els resultats. Vegeu com primerament iterarem sobre $n$ tantes vegades com s'hagi indicat en la entrada. Alhora, també iterarem per cada $n$ sobre una probabilitat de fallida de percolació. Aquest bucle tindrà 100 iteracions, $p \in \{0.00, 0.01, \dots, 1.00\}$. A més d'aquests dos bucles, iterarem una altra vegada sobre $p$ i $n$ tantes vegades com l'usuari hagi indicat en l'apartat \textit{IteracionsPerObtenirResultat}. Així, es farà una mitjana amb més o menys mostres. \\
	
	S'iniciarà un comptador a 0 que representarà el nombre de grafs percolats connexos. S'utilitzarà el generador de grafs seleccionat a les opcions per generar el graf que posteriorment serà percolat. Vegeu que aquí generarem grafs fins a aconseguir un graf connex. Aquesta decisió la vam prendre per tenir una representació més acurada de la transició de fase. Més endavant, es tornarà a considerar aquesta decisió, ja que hi ha grafs, com ara el \textit{Random Geometric Graph}, que requereixen un paràmetre $r$, el qual, amb valors petits de $r$, acostuma a generar grafs no connexos. \\
	
	Per acabar, percolarem el graf $G(V,E)$ de la manera que s'hagi especificat a l'input, ja sigui per nodes o per arestes, obtenint $G_{\text{p}}$. A $G_{\text{p}}$ se li aplicarà un algorisme que determinarà si el graf és connex. Si ho és, s'incrementarà el comptador. Quan les \textit{IteracionsPerObtenirResultat} s'hagin completat, s'escriurà l'entrada resultant al fitxer \texttt{PATH.csv}.
	
	
	\newpage
	\section{Conclusions}
	
	\newpage
	\section{Bibliografia}
	
	\begin{itemize}
		\item \href{https://ca.wikipedia.org/wiki/Model_d%27Erd%C5%91s-R%C3%A9nyi}{Wikipedia. \textit{Model d'Erdős-Rényi}}.
	\end{itemize}
	
	\newpage
	\section{Annex}
	
	
	
\end{document}
