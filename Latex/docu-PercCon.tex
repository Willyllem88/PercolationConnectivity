\documentclass[a4paper]{article}
\usepackage[a4paper,left=3cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{{./images/}}
\usepackage{hyperref}
\usepackage{float}

\usepackage{algorithm}
\floatname{algorithm}{Algorisme} % Cambia "Algorithm" por "Algorisme"

\usepackage{algpseudocode}
\usepackage{titling}
\usepackage{lipsum}
\usepackage{color}

\title{\textbf{\huge Algorismia}\\[0.5cm]
	\textbf{\Large Estudi Experimental de Connectivitat i Percolació de Grafs}}
\author{\emph{Pau Belda, Guillem Cabré, Marc Peñalver, Prisca Oleart}}
\date{\textbf{Curs 2024-25, Quatrimestre de tardor}}

\renewcommand*\contentsname{Continguts}
\renewcommand{\figurename}{Figura}

\begin{document}
	
	\begin{titlepage}
		\clearpage\maketitle
		\thispagestyle{empty}
	\end{titlepage}
	
	\tableofcontents
	\clearpage
	
	\section{Definicions}
		
	\subsection{Percolació}
	
	La percolació en un graf $G$ consisteix en eliminar o desactivar nodes o arestes, i posteriorment es mesura com això afecta una certa propietat global del graf. Quan desactivem una aresta o un node, direm que ha tingut una fallida. \\
	
	En termes generals, l'objectiu és estudiar com el graf passa d'estar completament connectat a parcialment o totalment desconnectat a mesura que es treuen alguns dels seus components. Quan parlem de percolació, considerem una probabilitat $p$ que determina si una component del graf (node o aresta) es desactiva aleatòriament. Aquest mecanisme és especialment rellevant per a l'estudi de xarxes complexes, ja que ens ajuda a comprendre com de robust o vulnerable és el sistema que volem analitzar.
	
	\begin{itemize}
		\item \textbf{Percolació per nodes}: Cada node té una probabilitat $p$ de ser desactivat. Un cop fet això, s'analitza com ha canviat la connectivitat del graf.
		\item \textbf{Percolació per arestes}: En aquest cas, les arestes es desactiven en lloc dels nodes. Això també afecta la connectivitat, ja que les connexions directes entre nodes es perden.
	\end{itemize}
	
	Després d'aplicar el procés de percolació (sobre nodes o arestes), s'obté un graf percolat, que és la versió modificada del graf original, amb una connectivitat reduïda i, possiblement, components desconnectats. Aquest graf l'anomenarem $G_{\text{p}}$.
	
	\subsection{Transició de Fase}
	
	Una transició de fase d'un graf per a una propietat concreta $\Pi$ fa referència a un resultat satisfactori d'un procés de percolació aplicat al graf. En el nostre cas aquesta propietat $\Pi$ serà la connectivitat del graf. \\
	
	Definim un resultat com a satisfactori si, donat que es troba una probabilitat de valor $q$ tal que es compleix la propietat $\Pi$ al graf $G_q$ (definim aquesta probabilitat com $q_{\Pi}$), per als grafs $G_{q'}$ on $q' > q_{\Pi}$, aquests verifiquen la propietat $\Pi$, i als grafs $G_{q'}$ on $q' < q_{\Pi}$, no la verifiquen (ambdues afirmacions són vàlides si es compleixen amb una probabilitat prou alta). \\
	
	Quan s'ha obtingut aquest resultat, diem que la propietat $\Pi$ presenta una transició de fase al voltant de $q_{\Pi}$. \\
	
	
	\subsection{Objectius de la Experimentació}
	
	En aquesta secció s'exposen els grafs seleccionats per a l'estudi experimental. Es detallaran les característiques específiques de cada graf, així com els algorismes utilitzats per a la seva generació. Posteriorment, explicarem per què aquests grafs han estat considerats els més rellevants per al nostre estudi.
	\newpage
	\section{Grafs Seleccionats}
	En aquesta secció s'exposen els grafs seleccionats per a l'estudi experimental. Concretament, explicarem les peculiaritats de cada graf. Així mateix, es detallaran els algorismes utilitzats per a la generació de cada tipus de graf. Posteriorment, exposarem per que aquests son els que mes ens han semblat interresants per fer l'estudi. 
	\subsection{Erdős-Rényi}
	
	\begin{algorithm} [H]
		\caption{Generació de graf Erdős-Rényi $G(n, p)$}
		\begin{algorithmic} [1]
			\Statex \textbf{Entrada:} $n$ (dimensió de la graella), $p$ (probabilitat d'establir aresta entre nodes)
			\Statex \textbf{Sortida:} Graf $g$
			\Statex \vspace{-0.25em}
			\State Inicialitzar el graf $g$ amb $n$ nodes
			\For{$i = 0$ fins a $n-1$}
			\For{$j = i + 1$ fins a $n-1$}
			\If{rand01() \textless\, $p$}
			\State Afegir una aresta entre $i$ i $j$ al graf $g$
			\EndIf
			\EndFor
			\EndFor
			\State Retornar el graf $g$
		\end{algorithmic}
	\end{algorithm}
	
	El generador de grafs Erdős-Rényi crea un graf aleatoriitzant la connexió entre nodes. Sigui $p$ la probabilitat d'establir una aresta entre qualsevol parell de nodes del graf. Per a cada parell de nodes $(i, j)$, es genera un nombre aleatori mitjançant la funció $rand01()$, que retorna un valor entre 0 i 1. Si aquest valor és menor que $p$, s'estableix una aresta entre $i$ i $j$. Aquest procés es repeteix per a tots els parells possibles de nodes. \\
	
	La instrucció $j = i + 1$ en el bucle interior assegura que només es considerin les arestes entre nodes diferents i evita la duplicació d'arestes. Això és important perquè en un graf no dirigit, l'aresta entre $i$ i $j$ és la mateixa que l'aresta entre $j$ i $i$. D'aquesta manera, es redueix el nombre de connexions a calcular i s'assegura que cada aresta es consideri només una vegada. \\
	
	\subsection{Graella Quadrada}

	\begin{algorithm} [H]
		\caption{Generació de Graf de Graella Quadrada $G(m \times m)$}
		\begin{algorithmic} [1]
			\Statex \textbf{Entrada:} $m$ (dimensió de la graella)
			\Statex \textbf{Sortida:} Graf $g$ 
			\Statex \vspace{-0.25em}
			\State Inicialitzar $n = m \times m$ (nombre de nodes del graf)
			\State Crear un graf buit $g$ amb $n$ nodes
			\For{$i = 0$ fins a $m-1$}
				\For{$j = 0$ fins a $m-1$}
					\State $nodeActual = i \times m + j$
					\If{$i < m-1$} 
						\State $nodeFilaInferior = (i + 1) \times m + j$
						\State Afegir una aresta entre $nodeActual$ i $nodeFilaInferior$
					\EndIf
					\If{$j<m-1$}
						\State $nodeColumnaDreta = i \times m + (j + 1)$
						\State Afegir una aresta entre $nodeActual$ i $nodeColumnaDreta$
					\EndIf
				\EndFor
			\EndFor
			\State Retornar el graf $g$
		\end{algorithmic}
	\end{algorithm}

	El generador de grafs de graella quadrada crea un graf amb una estructura regular en què cada node és adjacent als nodes de la fila superior, inferior, esquerra i dreta, si aquests existeixen. Aixó s'aconsegueix comprovant per cada node si existeixen nodes a la fila inferior i a la columna dreta, i si és així, s'afegeixen les arestes corresponents. \\

	\subsection{Graella Triangular}

	\begin{algorithm} [H]
		\caption{Generació de Graf de Graella Triangular $G(rows)$}
		\begin{algorithmic} [1]
			\Statex \textbf{Entrada:} $rows$ (nombre de files)
			\Statex \textbf{Sortida:} Graf $g$
			\Statex \vspace{-0.25em}
			\State Inicialitzar $n = \frac{rows \times (rows + 1)}{2}$ (nombre de nodes del graf)
			\State Crear un graf buit $g$ amb $n$ nodes
			\State $nodeActual = 0$
			\For{$i = 0$ fins a $rows-1$}
				\For{$j = 0$ fins a $i$}
					\If{$j < i$}
						\State $nodeDreta = nodeActual + 1$
						\State Afegir una aresta entre $nodeActual$ i $nodeDreta$
					\EndIf
					\If{$i < rows-1$}
						\State $nodeInferiorEsquerra = nodeActual + i + 1$
						\State Afegir una aresta entre $nodeActual$ i $nodeInferiorEsquerra$
						\State $nodeInferiorDret = nodeActual + i + 2$
						\State Afegir una aresta entre $nodeActual$ i $nodeInferiorDret$
					\EndIf
					\State $nodeActual = nodeActual + 1$
				\EndFor
			\EndFor
			\State Retornar el graf $g$
		\end{algorithmic}
	\end{algorithm}
	
	El generador de grafs de graella triangular crea un graf amb \( n \) nodes, on \( n = 1 + 2 + 3 + \ldots + rows = \frac{rows \times (rows + 1)}{2} \). Aquests nodes tenen una estructura en què cada node està connectat als veïns de la dreta i l'esquerra, així com als nodes superiors i inferiors, tant a l'esquerra com a la dreta, sempre que aquests existeixin. Això s'aconsegueix comprovant per a cada node si hi ha nodes a la fila inferior i a la columna dreta, i si és així, s'afegeixen les arestes corresponents. \\

	\subsection{Graf Geomètric Aleatori}
	\begin{algorithm} [H]
		\caption{Generació de Graf Geomètric Aleatori $G(n, r)$}
		\begin{algorithmic} [1]
			\Statex \textbf{Entrada:} $n$ (nombre de nodes), $r$ (radi de connexió)
			\Statex \textbf{Sortida:} Graf $g$
			\Statex \vspace{-0.25em}
			\State Crear un graf buit $g$ amb $n$ nodes
			\State Inicialitzar un vector de coordenades $coords$ de longitud $n$
			\For{$i = 0$ fins a $n-1$}
				\State $coords[i].x = \text{rand01}()$
				\State $coords[i].y = \text{rand01}()$
			\EndFor
			\For{$i = 0$ fins a $n-1$}
				\For{$j = i + 1$ fins a $n-1$}
					\State $dist_x = coords[i].x - coords[j].x$
					\State $dist_y = coords[i].y - coords[j].y$
					\If{$\sqrt{dist_x^2 + dist_y^2} < r$}
						\State Afegir una aresta entre $i$ i $j$ al graf $g$
					\EndIf
				\EndFor
			\EndFor
			\State Retornar el graf $g$
		\end{algorithmic}
	\end{algorithm}
	El generador de grafs geomètrics aleatoris crea un graf amb \( n \) nodes, on cada node es col·loca aleatòriament en un espai bidimensional unitari. Dos nodes estan connectats per una aresta si la distància entre ells és menor que un radi \( r \) especificat. Això es determina calculant la distància euclidiana entre tots els parells de nodes i afegint arestes quan la distància és inferior a \( r \).
		
	\subsection{Graf de Barabási-Albert}

	\begin{algorithm} [H]
		\caption{Generació de Graf de Barabási-Albert $G(n, m_0, m)$}
		\begin{algorithmic} [1]
			\Statex \textbf{Entrada:} $n$ (nombre de nodes), $m_0$ (nombre de nodes inicials), $m$ (grau de connexió per nou node)
			\Statex \textbf{Sortida:} Graf $g$
			\Statex \vspace{-0.25em}
			\State Crear un graf buit $g$ amb $n$ nodes
			\State Inicialitzar un vector $connection\_degree$ de longitud $n$
			\For{$i = 0$ fins a $m_0 - 1$}
				\For{$j = i + 1$ fins a $m_0 - 1$}
					\State Afegir una aresta entre $i$ i $j$ al graf $g$
				\EndFor
				\State $connection\_degree[i] = m_0 - 1$
			\EndFor
			\For{$i = m_0$ fins a $n - 1$}
				\State Inicialitzar un vector buit $candidates$
				\While{la longitud de $candidates$ és menor que $m$}
					\State $selectedNode = \text{preferentialAttachment}(connection\_degree)$
					\If{$selectedNode$ no està en $candidates$}
						\State Afegir $selectedNode$ a $candidates$
					\EndIf
				\EndWhile
				\For{cada $j$ en $candidates$}
					\State Afegir una aresta entre $i$ i $j$ al graf $g$
					\State $connection\_degree[j] += 1$
				\EndFor
				\State $connection\_degree[i] = m$
			\EndFor
			\State Retornar el graf $g$
		\end{algorithmic}
	\end{algorithm}
	
	El generador de grafs de Barabási-Albert crea un graf que segueix el model de creixement de xarxes, on s'afegeixen nodes nous que es connecten a nodes existents en funció del seu grau de connexió. Comença amb un conjunt inicial de \( m_0 \) nodes completament connectats, i cada nou node que s'afegeix selecciona \( m \) nodes existents per connectar-se, amb una probabilitat proporcional al seu grau de connexió. \\
	
	Aquesta selecció es realitza mitjançant la funció \texttt{preferentialAttachment}, que s'encarrega de seleccionar un node existent basant-se en el seu grau de connexió. La funció funciona de la següent manera: \\
	
	\begin{algorithm} [H]
		\caption{Preferential Attachment}
		\begin{algorithmic} [1]
			\Statex \textbf{Entrada:} $connection\_degree$ (vector de graus de connexió)
			\Statex \textbf{Sortida:} $chosen$ (node seleccionat)
			\State Inicialitzar $degree\_sum = 0$, $temp\_sum = 0$
			\For{cada $i$ en $connection\_degree$}
				\State $degree\_sum \mathrel{+}= i$
			\EndFor
			\State $random\_num = \text{rand()} \mod degree\_sum$
			\For{$i = 0$ fins a \text{length(connection\_degree)} - 1}
				\State $temp\_sum \mathrel{+}= connection\_degree[i]$
				\If{$random\_num \leq temp\_sum$}
					\State $chosen \gets i$
					\State
				\EndIf
			\EndFor
			\State Retornar $chosen$
		\end{algorithmic}
	\end{algorithm}
	
	Aquesta funció calcula la suma total dels graus de connexió de tots els nodes existents i selecciona aleatòriament un node, on la probabilitat de seleccionar cada node és proporcional al seu grau de connexió. Així, els nodes amb més connexions tenen una major probabilitat de ser seleccionats, promovent el creixement de xarxes amb característiques d'escala.
	
	\newpage
	\section{Algoritmes}

	En aquesta secció es presenten els principals algorismes emprats en l'estudi de la transició de fase. A continuació, detallarem cada algorisme i donarem una breu explicació d'aquests. Els algorismes abordats són els següents:

	\subsection{Percolació per Arestes}
	\begin{algorithm} [H]
		\caption{Percolació d'Arestes en un Graf}
		\begin{algorithmic} [1]
			\Statex \textbf{Entrada:} Graf $G = (V, E)$ amb $n$ nodes, probabilitat $p$
			\Statex \textbf{Sortida:} Graf percolat $G' = (V, E')$ on $E' \subseteq E$
			\Statex \vspace{-0.25em}
			\State Crear un nou graf buit $G'$ amb $n$ nodes (còpia profunda de $G$)
			\For{cada node $u$ en $V$}
				\For{cada node $v$ en la llista d'adjacència d'$u$ d'el graf $G$}
					\If{$u < v\ \land\ rand01() > p$}
						\State Afegir l'aresta $(u, v)$ al graf $G'$
					\EndIf
				\EndFor
			\EndFor
			\State Retornar el graf $G'$
		\end{algorithmic}
	\end{algorithm}

	Aquest algorisme retorna el graf percolat a partir del graf original. Això s'aconsegueix eliminant les arestes amb una probabilitat \( p \). Per evitar processar una mateixa aresta més d'una vegada, s'utilitza la condició \( u < v \), ja que en grafs no dirigits una aresta \( (u, v) \) és equivalent a \( (v, u) \). Tal com s'ha mencionat prèviament, la funció \texttt{rand01()} genera un nombre aleatori entre 0 i 1, que es compara amb la probabilitat \( p \) per decidir si es manté o s'elimina una aresta.

	\subsection{Percolació per Nodes}
	\begin{algorithm} [H]
		\caption{Percolació de Nodes en un Graf}
		\begin{algorithmic} [1]
			\Statex \textbf{Entrada:} Graf $G = (V, E)$ amb $n$ nodes, probabilitat $p$
			\Statex \textbf{Sortida:} Graf percolat $G' = (V', E')$ on $V' \subseteq V$ i $E' \subseteq E$
			\Statex \vspace{-0.25em}
			\State Inicialitzar un vector $posicioNodes$ de longitud $n$
			\State Assignar $nbNodesVius = n$
			\For{cada node $u$ en $V$}
				\State Generar un valor aleatori $r = \texttt{rand01}()$
				\If{$r < p$}
					\State Marcar el node $u$ com a fallat
					\State Decrementar $nbNodesVius$
				\Else
					\State Actualitzar la posició del node viu $posicioNodes[u] = u - n + nbNodesVius$
				\EndIf
			\EndFor
			\Statex
			\State Crear un graf buit $G'$ amb $nbNodesVius$ nodes
			\For{cada node $u$ en $V$}
				\If{$u$ no ha fallat}
					\For{cada node $v$ en la llista d'adjacència de $u$ en $G$}
						\If{$v$ no ha fallat $\land\ u < v$}
							\State Afegir l'aresta $(posicioNodes[u], posicioNodes[v])$ a $G'$
						\EndIf
					\EndFor
				\EndIf
			\EndFor
			\State Retornar el graf $G'$
		\end{algorithmic}
	\end{algorithm}

	Aquest algorisme retorna el graf percolat a partir del graf original eliminant nodes amb una probabilitat $p$. Per a cada node, es genera un valor aleatori entre 0 i 1 mitjançant la funció \texttt{rand01()}. Si aquest valor és inferior a $p$, el node es considera eliminat (fallat) i no es conservarà en el graf resultant. \\
	Els nodes que sobreviuen són reindexats per assegurar que el nou graf té una numeració consecutiva de nodes. Les arestes només es conserven si ambdós nodes que connecten han sobreviscut, i es manté la condició $u<v$ per evitar afegir la mateixa aresta dues vegades, ja que en els grafs no dirigits una aresta $(u,v)$ és equivalent a $(v,u)$. Així, el resultat és un graf amb una mida reduïda en funció de la probabilitat $p$, mantenint només els nodes i arestes que han "sobreviscut" al procés de percolació.
	
	\subsection{Càlcul de Components Connexes}
	\begin{algorithm} [H]
		\caption{Càlcul del Nombre de Components Connexes}
		\begin{algorithmic} [1]
			\Statex \textbf{Entrada:} Graf $G = (V, E)$ amb $n$ nodes
			\Statex \textbf{Sortida:} Nombre de components connexos $componentCount$
			\Statex \vspace{-0.25em}
			\State Inicialitzar un vector $visited$ de longitud $n$ amb valors $false$
			\State Inicialitzar $componentCount = 0$
			\For{cada node $i = 0$ fins a $n - 1$}
				\If{el node $i$ no ha estat visitat}
					\State Incrementar $componentCount$
					\State Realitzar una DFS a partir del node $i$, marcant els nodes visitats
				\EndIf
			\EndFor
			\State Retornar $componentCount$
		\end{algorithmic}
	\end{algorithm}
	
	L'algorisme utilitza una cerca en profunditat (DFS) per explorar cada component connex del graf. Cada vegada que es troba un node no visitat, es crida la funció \texttt{dfs} per explorar recursivament tots els nodes connectats a aquest node. Aquesta crida recursiva assegura que tots els nodes del mateix component quedin marcats com a visitats, evitant comptar-los més d'una vegada. 

	\newpage
	\section{Experimentació}
	
	Per dur a terme l'experimentació del projecte, hem utilitzat diferents eines. Hem programat dos programes en \texttt{C++}, un llenguatge que ens ofereix molta eficàcia temporal i espacial. Aquests programes són el \texttt{main} i el \texttt{runner}. També hem dissenyat un fitxer de classe \texttt{graph} amb tots els atributs i funcions necessàries per operar amb els grafs. Aquesta classe representa els grafs com a llistes d'adjacència. \\
	
	Per compilar aquests programes, hem fet ús del programari lliure \texttt{make}, que automatitza i paral·litza el compilatge i l'enllaç. \\
	
	A més, hem dissenyat scripts per a l'interpret \texttt{R}, que és un programari de tractament de dades que ens analitzarà i generarà gràfics dels resultats dels estudis, que estaran en format \texttt{.csv}. \\
	
	Més informació del procés d'experimentació es pot trobar en el GitHub del projecte, premeu \href{https://github.com/Willyllem88/PercolationConnectivity}{\texttt{aquí}} per accedir-hi. Allà, a part del codi, també podreu consultar més informació sobre la generació de grafs, les dependències del programa per compilar-lo i executar-lo, com inserir els paràmetres pels programes i més. \\
	
	\subsection{Metodologia}
	
	El programa \texttt{main}, mitjançant la classe \texttt{graph}, ens ha permès analitzar les propietats del canvi de fase a partir dels paràmetres inicials. Aquests paràmetres són els següents:
	
	\begin{itemize}
		\item \textbf{RandomSeed}: La llavor per al generador aleatori.
		\item \textbf{NúmeroMínimNodes}: El nombre mínim de nodes del graf.
		\item \textbf{NúmeroMàximNodes}: El nombre màxim de nodes del graf.
		\item \textbf{NúmeroNodesStep}: Increment dels nodes en cada iteració.
		\item \textbf{IteracionsPerObtenirResultat}: El nombre de vegades que es provarà la configuració per probabilitat $p$ de percolació i per nombre de vèrtex $n$.
		\item \textbf{ModePercolació}: Tipus de percolació per nodes o per arestes.
		\item \textbf{PathResultat}: Fitxer on es guardaran els resultats.
		\item \textbf{AlgorismeGeneradorGraf}: Algoritme utilitzat per generar el graf (per exemple, Erdős-Rényi, Square-Grid, etc.).
		\item \textbf{ParàmetresAlgorisme}: Paràmetres addicionals per al generador de graf (opcional segons l'algorisme).
	\end{itemize}
	
	A partir d'aquests paràmetres, el programa \texttt{main} escriurà un fitxer \texttt{PATH.csv} que posteriorment serà analitzat mitjançant el software de tractament de dades \texttt{R}. \\
	
	Per altra banda, tenim el programa \texttt{runner}, que rebrà com a input un fitxer de text. Aquest fitxer tindrà un llistat de paràmetres per diferents experiments del programa \texttt{main}. Un exemple d'això seria:
	
	\begin{verbatim}
		RGN   MIN MAX  STEP ITs   PERC-MODE  RESULT-PATH      GEN-ALGORITM    PARAMETERS-GEN
		------------------------------------------------------------------------------------
		21312 10  100   10  1000  NODE_PERC  ./data/test1.csv Erdos-Renyi        0.1
		35353 50  500   50  1000  EDGE_PERC  ./data/test2.csv Random-Geometric   0.3
		72479 100 1000  100 100   EDGE_PERC  ./data/test3.csv Square-Grid
	\end{verbatim}
	
	El programa \texttt{runner}, per cada fila del fitxer que rep, inicialitzarà una instància del programa \texttt{main}, aconseguint d'aquesta manera automatitzar molt més els tests, podent córrer diferents programes \texttt{main} simultàniament. \\
	
	\subsection{Programa Main}
	
	Per entendre els resultats també s'ha d'entendre les decisions que s'han pres per la recollida de dades. Analitzarem el programa \texttt{main} mitjançant un pseudocodi per no entrar en conceptes avançats de \texttt{C++}. A continuació vegeu una mostra del pseudocodi: \\
	
	\begin{algorithm} [H]
		\caption{Descripció de l'experiment}
		\begin{algorithmic}[1]
			\State Seleccionar opcions de configuració
			\State Inicialitzar el generador de nombres aleatoris
			\State Obrir l'arxiu CSV i escriure la capçalera
			\For{$n$ in range(MIN\_NB\_NODES, MAX\_NB\_NODES + 1, NB\_NODES\_STEP)}
			\For{$p$ des de 0 fins a 1 amb pas 0.01}
			\State Inicialitzar el comptador de grafs connexos
			\For{$i = 0$ fins a TRIES\_PER\_P}
			\Repeat
			\State Generar el graf seleccionat($p$, $n$, $params$)
			\Until{el graf és connex}
			\State Aplicar percolació (per nodes o arestes) al graf
			\If{el graf percolat és connex}
			\State Incrementar el comptador de grafs connexos
			\EndIf
			\EndFor
			\State Escriure entrada resultant al CSV
			\EndFor
			\EndFor
		\end{algorithmic}
	\end{algorithm}
	
	Ara, analitzarem el codi. Per començar, el programa preguntarà per totes les opcions necessàries. D'aquesta manera, ens podem permetre tenir un sol programa que pugui fer tot el que necessitem i que sigui altament modular. S'utilitzarà la llavor per generar nombres aleatoris, i així l'experiment podrà ser repetit amb els mateixos resultats. Després, crearà el fitxer \texttt{PATH.csv}, al qual s'hi inseriran entrades que posteriorment s'analitzaran. \\
	
	Ara analitzarem l'algorisme encarregat de generar els resultats. Vegeu com primerament iterarem sobre $n$ tantes vegades com s'hagi indicat en la entrada. Alhora, també iterarem per cada $n$ sobre una probabilitat de fallida de percolació. Aquest bucle tindrà 100 iteracions, $p \in \{0.00, 0.01, \dots, 1.00\}$. A més d'aquests dos bucles, iterarem una altra vegada sobre $p$ i $n$ tantes vegades com l'usuari hagi indicat en l'apartat \textit{IteracionsPerObtenirResultat}. Així, es farà una mitjana amb més o menys mostres. \\
	
	S'iniciarà un comptador a 0 que representarà el nombre de grafs percolats connexos. S'utilitzarà el generador de grafs seleccionat a les opcions per generar el graf que posteriorment serà percolat. Vegeu que aquí generarem grafs fins a aconseguir un graf connex. Aquesta decisió la vam prendre per tenir una representació més acurada de la transició de fase. Més endavant, es tornarà a considerar aquesta decisió, ja que hi ha grafs, com ara el \textit{Random Geometric Graph}, que requereixen un paràmetre $r$, el qual, amb valors petits de $r$, acostuma a generar grafs no connexos. \\
	
	Per acabar, percolarem el graf $G(V,E)$ de la manera que s'hagi especificat a l'input, ja sigui per nodes o per arestes, obtenint $G_{\text{p}}$. A $G_{\text{p}}$ se li aplicarà un algorisme que determinarà si el graf és connex. Si ho és, s'incrementarà el comptador. Quan les \textit{IteracionsPerObtenirResultat} s'hagin completat, s'escriurà l'entrada resultant al fitxer \texttt{PATH.csv}.
	
	\subsection{Graella quadrada}
	
	Per estudiar la possible transició de fase a graelles quadrades hem decidit fer proves amb grafs de mida petita, des de 2x2 nodes a 20x20, així com amb grafs de mida més gran, de 20x20 nodes a 200x200. Això ens servirà per estudiar el comportament de la percolació tant per node com per aresta en diferents escales de complexitat. Hem triat aquestes mides de grafs per poder comparar resultats en diferents dimensions i observar com la mida del graf influeix en la percolació, formació de components connexes i transició de fase.
	
	\subsubsection{Mida petita}
	
	\textbf{Percolació per aresta}
	
	
	\includegraphics[height=12cm]{images/squareE-2-20-1}
	
	
	\textbf{Percolació per node}
	
	\includegraphics[height=12cm]{images/squareN-2-20-1}
	
	\subsubsection{Mida gran}
	
	\textbf{Percolació per aresta}
	
	\includegraphics[height=12cm]{images/squareE-20-200}
	
	\textbf{Percolació per node}
	
	\includegraphics[height=12cm]{images/squareN-20-200}
	
	\subsection{Graella triangular}
	
	Ara estudiem la transició de fase en graelles triangulars. Per l'experimentació hem fet el mateix que en les graelles quadrades, estudiar la percolació per aresta i per node en grafs de mida petita i mida gran. En aquest cas, els grafs petits comencen amb 5 files fins a 55 files, amb increment de 5 files cada vegada, mentre que la mida gran son grafs de 50 a 150 files amb increments de 10 files.
	
	\subsubsection{Mida petita}
	
	\textbf{Percolació per aresta}
	
	
	\includegraphics[height=12cm]{images/triangularE-5-55-1000}
	
	
	\textbf{Percolació per node}
	
	\includegraphics[height=12cm]{images/triangularN-5-55-1000}
	
	\subsubsection{Mida gran}
	
	\textbf{Percolació per aresta}
	
	
	\includegraphics[height=12cm]{images/triangularE-50-150}
	
	
	\textbf{Percolació per node}
	
	\includegraphics[height=12cm]{images/triangularN-50-150}
	
	
	\newpage
	\section{Conclusions}
	
	\newpage
	\section{Bibliografia}
	
	\begin{itemize}
		\item \href{https://ca.wikipedia.org/wiki/Model_d%27Erd%C5%91s-R%C3%A9nyi}{Wikipedia. \textit{Model d'Erdős-Rényi}}.
	\end{itemize}
	
	\newpage
	\section{Annex}
	
	
	
\end{document}
